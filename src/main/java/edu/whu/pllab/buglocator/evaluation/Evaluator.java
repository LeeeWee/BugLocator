package edu.whu.pllab.buglocator.evaluation;

import java.io.BufferedReader;
import java.io.FileReader;
import java.util.HashMap;
import java.util.List;
import java.util.Map.Entry;
import java.util.concurrent.ExecutorService;
import java.util.concurrent.Executors;

import org.slf4j.Logger;
import org.slf4j.LoggerFactory;

import edu.whu.pllab.buglocator.Property;
import edu.whu.pllab.buglocator.common.BugReport;
import edu.whu.pllab.buglocator.rankingmodel.IntegratedScore;

public class Evaluator {

	private static final Logger logger = LoggerFactory.getLogger(Evaluator.class);
	
	private String predictionsPath;

	/** testIntegratedScores generated by RankingModelGenerator */
	private HashMap<BugReport, List<IntegratedScore>> testIntegratedScores;
	
	private ExperimentResult experimentResult;
	
	private final int[] N = ExperimentResult.N_ARRAY;
	private int[] topN = new int[N.length];
	private double[] topNRate = new double[N.length];
	
	private Double sumOfRR = 0.0;
	private Double sumOfAP = 0.0;
	private Double MRR = 0.0;
	private Double MAP = 0.0;
	
	/** Constructor */
	public Evaluator(HashMap<BugReport, List<IntegratedScore>> testIntegratedScores) {
		Property property = Property.getInstance();
		this.predictionsPath = property.getPredictionsPath();
		this.testIntegratedScores = testIntegratedScores;
	}
	
	/** load predictions result generated by svm_rank_classify tool */
	public void loadPredictionsResult() {
		logger.info("Loading predictions result...");
		try {
			BufferedReader reader = new BufferedReader(new FileReader(predictionsPath));
			String line = "";
			for (Entry<BugReport, List<IntegratedScore>> entry : testIntegratedScores.entrySet()) {
				for (IntegratedScore integratedScore : entry.getValue()) {
					line = reader.readLine();
					if (line == null) {
						logger.error("Predictions result doesn't match test IntegratedScores!");
						System.exit(0);
					}
					integratedScore.setIntegratedScore(Double.parseDouble(line));
				}
			}
			reader.close();
		} catch (Exception e) {
			e.printStackTrace();
		} 
		
		// rank predictions
		logger.info("Ranking predictions result by integratedScore...");
		for (Entry<BugReport, List<IntegratedScore>> entry : testIntegratedScores.entrySet()) {
			entry.getValue().sort(new IntegratedScore.IntegratedScoreComparator());
		}
	}
	
	public void evaluate() {
		logger.info("Evaluating...");
		ExecutorService executor = Executors.newFixedThreadPool(Property.THREAD_COUNT);
		for (Entry<BugReport, List<IntegratedScore>> entry : testIntegratedScores.entrySet()) {
			Runnable worker = new WorkerThread(entry.getKey(), entry.getValue());
			executor.execute(worker);
		}
		executor.shutdown();
		while (!executor.isTerminated()) {
		}
		
		int testDataSize = testIntegratedScores.size();
		// catculate topNRate, MRR, MAP
		for (int i = 0; i < topN.length; i++) {
			topNRate[i] = (double) topN[i] / testDataSize;
		}
		MRR = sumOfRR / testDataSize;
		MAP = sumOfAP / testDataSize;
		
		experimentResult = new ExperimentResult(testDataSize, topN, topNRate, sumOfRR, MRR, sumOfAP, MAP);
		System.out.println("");
		System.out.println("=====================Experiment Result =========================");
		System.out.println(experimentResult.toString());
		System.out.println("================================================================");
		System.out.println("");
	}
	
	/** Worker calculate metrics */
	private class WorkerThread implements Runnable {

		private BugReport bugReport;
		private List<IntegratedScore> integratedScores;
		
		public WorkerThread(BugReport bugReport, List<IntegratedScore> integratedScores) {
			this.bugReport = bugReport;
			this.integratedScores = integratedScores;
		}
		
		@Override
		public void run() {
			calculateTopN();
			calculateMRR();
			calulateMAP();
		}
		
		/** for n in N, calculate accuracy@n(top@n) */
		private void calculateTopN() {
			for (int i = 0; i < integratedScores.size(); i++) {
				if (i >= N[N.length - 1])
					break;
				IntegratedScore integratedScore = integratedScores.get(i);
				if (bugReport.isModified(integratedScore.getPath())) {
					synchronized (topN) {
						for (int j = 0; j < N.length; j++) {
							int n = N[j];
							if (i < n) {
								for (int k = j; k < N.length; k++) {
									topN[k]++;
								}
								break;
							}
						}
					}
					break;
				}
			}
		}
		
		/** calculate sum Of Reciprocal Rank */
		private void calculateMRR() {
			for (int i = 0; i < integratedScores.size(); i++) {
				IntegratedScore integratedScore = integratedScores.get(i);
				if (bugReport.isModified(integratedScore.getPath())) {
					synchronized(sumOfRR) {
						sumOfRR += (1.0 / (i + 1));
					}
					break;
				}
			}
		}
		
		/** calculate sumOf Average Precision */
		private void calulateMAP() {
			double AP = 0.0;
			int numberOfPositiveInstances = 0;
			for (int i = 0; i < integratedScores.size(); i++) {
				IntegratedScore integratedScore = integratedScores.get(i);
				if (bugReport.isModified(integratedScore.getPath())) {
					numberOfPositiveInstances++;
				}
			}
			int numberOfFixedFiles = 0;
			double precision = 0.0;
			for (int i = 0; i < integratedScores.size(); i++) {
				IntegratedScore integratedScore = integratedScores.get(i);
				if (bugReport.isModified(integratedScore.getPath())) {
					numberOfFixedFiles++;
					precision = ((double) numberOfFixedFiles) / (i + 1);
					AP += (precision / numberOfPositiveInstances);
				}
			}
			synchronized(sumOfAP) {
				sumOfAP += AP;
			}
		}
		
	}

	public HashMap<BugReport, List<IntegratedScore>> getTestIntegratedScores() {
		return testIntegratedScores;
	}

	public void setTestIntegratedScores(HashMap<BugReport, List<IntegratedScore>> testIntegratedScores) {
		this.testIntegratedScores = testIntegratedScores;
	}

	public ExperimentResult getExperimentResult() {
		if (experimentResult == null)
			evaluate();
		return experimentResult;
	}

	public String getPredictionsPath() {
		return predictionsPath;
	}

	public void setPredictionsPath(String predictionsPath) {
		this.predictionsPath = predictionsPath;
	}

}
